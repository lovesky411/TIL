# 자바 개발자를 위한 97가지 제안
> 자바 개발자를 위한 97가지 제안(케블린 헤니, 트리샤 지/ 제이펍/ 2020)
#### 알아야 할 것도, 해야 할 것도, 그 일을 수행하는 방법도 너무나 많기에 어느 한 사람이나 하나의 논리도 '하나의 정답'을 주장할 수는 없다.
각기 다른 저자의 이야기는 반드시 일맥상통하지 않으며, 그럴 의도도 없다. 오히려 그 반대다. 저마다의 이야기는 그 독창성에 가치가 있다.
이 모음집의 가치는 각각의 저자가 자기 생각을 보완하고 확인하며 때로는 다른 저자의 생각에 반박하는 것에 있다.
누군가의 생각이 특별히 더 중요한 것도 아니다. 읽어본 내용에 반응하고, 이를 반영하며 서로 연관짓고, 자기 생각과 지식,
경험에 기반해 어느 것에 더 무게를 둘 것인지 오로지 독자 여러분에게 달렸다.




### 01 자바만으로도 충분하다
자바는 훌륭한 언어이며 자바 클래스 라이브러리는 범용으로 설계되었다. 파일을 다뤄야 한다면 java.nio 라이브러리를 쓰면 된다. 데이터 베이스는 java.sql 라이브러리가 맡아준다. 
범용적이며 재사용 할 수 있다는 관점에서 보면 일종의 룰 엔진같은 것을 도입하고 싶어지기도 한다. 하지만 결국 룰 엔진을 설정하는 것도 프로그래밍이며, 이 경우 대부분은 자바보다 못한 언어를 사용하게 된다. **왜 그냥 자바로 코드를 쓰지 않을까?** 자바로 작성한 코드는 읽기 쉽고, 심지어 자바 프로그래머가 아니어도 쉽게 유지보수할 수 잇는 코드를 산출할 수 있다.
***유행을 좇지 말자***


### 02 확인 테스트
``
  assertEquals("", functionCall())  
``

위의 코드처럼 빈 값이나 의미 없는 값을 확인하는 테스트 코드를 작성해 본 적이 이는가? 
보통 functionCall 함수가 문자열을 리턴하는데 이 문자열이 정확히 어떤 값이어야 되는지 모르지만 리턴값을 보면 맞는지 아닌지 알 수 이는 경우 이런 코드를 작성한다. 
물론 처음 테스트를 실행하면 실패하게 되는데, 그 다음 리턴값을 복사해서 assertEquals 함수 파라미터로 복사해 넣는다. 이제 테스트를 다시 실행해보면 통과할 것이다.
이걸로 끝! 필자는 이 방법을 **확인테스트(approval testing)** 라고 부른다.
#### 확인테스트는 어떤 경우에 활용할 수 있을까?
- 변경해야 할 단위 테스트가 없는 코드
- JSON이나 XML을 리턴하는 REST API와 함수
- 복합 객체를 리턴하는 비즈니스 로직


### 03 AsciiDoc 으로 자바독 확장하기
간혹 자바독이 제공하는 API 문서, 즉 패키지와 프로젝트 개요 페이지 이외의 것이 필요한데, 이러한 것들은 자바독만으로 충분히 문서화할 수 없다.
아스키독이 이러한 것의 대안으로, 마크다운 같은 경량 마크업 형식처럼 즉각 읽을 수 잇는 구조로 되어 있다.


### 04 컨테이너를 제대로 이해하자
레거시 자바 애플리케이션을 레거시 자바 가상머신(JVM)상에서 있는 그대로 컨테이너화 하는 것은 위험하다. 오래된 JVM 을 도커 컨테이너에서 실행하면 어처구니 없는 일이 일어나기 때문이다.

컨테이너는 사실상 런타임 패키징 매커니즘의 표준이 되어가고 있다. 적정 수준의 격리화, 향상된 자원활용, 여러 호나경으로 애플리케이션을 배포할 수 있는 기능 등 여러 장점을 제공하기 때문이다.
자바의 경우 레거시 자바 애플리케이션과 의존성 그리고 애플리케이션이 사용하는 오래된 버전의 JVM 까지도 컨테이너에 욱여넣는 경우가 많다.
레거시 자바 애플리케이션 및 관련 환경을 컨테이너화하면 오래된 애플리케이션도 철 지난 인프라스트럭처에서 벗어나 최신 인프라스트럭처에서 실행할 수 있다. 하지만 이 방법의 장점을 취하려다 보면
JVM 어거노믹스(ergonomics)으로 인한 여러 위험 요소와 맞닥뜨리게 된다.
(JVM 어거노믹스 : JVM과 가비지 컬렉션이 애플리케이션 성능을 향상하기 위한 목적으로 실행하는 자기 학습 프로세스)
낮은 버전의 JVM 은 자신이 컨테이너안에서 실행중이라는 점을 인지하지 못해서 컨테이너가 아닌 호스트 OS의 지표를 측정하려 한다.  따라서 JVM이 잘못된 지표를 사용해 스스로를 튜닝하려고 시도하는 경우도 있다.

다음 명령 실행 시 JVM 어거노믹스가 설정한 JVM 매개변수를 확인 할 수 있다.
``
java -XX:+PrintFlagsFinal -version |grep ergonomic
``
JVM은 기본적으로 컨테이너 지원이 활성화되어 있지만
`` 
-XX:=UseContainerSupport
``
JVM 플래그를 이용해 비활성화 할 수 있다.

레거시 JVM을 도커 컨테이너에서 실행하는 것은 권장할 만한 것은 아니다. 하지만 컨테이너화가 유일한 옵션이라면 적어도 레거시 JVM 이 컨테이너에 할당된 자원을 초과해서 사용하지 않도록 하자.
가장 이상적이면서도 명확한 해결책은 기본적으로 컨테이너를 인지할 뿐 아니라 최신 버전이면서 안전한 런타임을 제공하는 버전의 JVM을 사용하는 것이다.



### 05 행위를 구현하는 것은 쉽지만 상태를 관리하는 것은 어렵다
캡슐화를 활용하면 소프트웨어 개발 분야에서 쉽게 찾아볼 수 있는 상태와 복잡도의 증가에 순응할 수 있다. 
상태를 내면화해서 다른 컴포넌트로부터 숨기며, 안전하게 디자인된 API로만 상태를 변경할 수 있게 하는 것이 캡슐화의 기본 개념이자 복잡한 정보 시스템을 디자인하고 구현하는 핵심이다.
최소한 자바 세계에서는 제대로 캡슐화된 시스템 구축에 대한 몇가지 권장 사례가 제대로 전파되지 않고 있다. 별다른 기능을 수행하지 않는 클래스의 자바빈 속성은 그저 게터와 세터에 의해 내부 상태를 외부로 노출하는 것이 일반적이며, 이미 대중화된 자바 엔터프라이즈 아키텍처는 거의 몯느 비즈니스 로직을 서비스 클래스에 구현하도록 하고 있다.
행위에 의해 발생한 버그를 특정 짓는 것은 비교적 '쉬운' 편이다. 반면 코드는 제대로 동작하는 것 같은데 여전히 버그가 존재하는 경우는 훨씬 복잡하다. 필자의 경험상 가장 해결하기 어려운 버그는 모순된 상태로 인해 발생하는 버그이다.
클래스가 제공하는 인터페이스 자체가 너무 가변적이고 접근이 쉬워서 어디에서든 아무런 방어 장치 없이 상태를 변경시킬 수 있다.

그렇다면 이 문제를 어떻게 해결할 수 있을까? **불변성(immutability)** 이 그 해법 중 하나이다.
객체가 불변임을 보장할 수 있고 객체를 생성하는 시점에 상태의 무결성을 검사할 수 있다면 시스템은 절대 모순된 상태가 되지 않을 것이다.
올바르게 구현한 팩토리 메서드와 빌더 패턴을 이용하면 가변 상태를 최소화 할 수 있다.
그러므로 세터를 자동으로 생성하지 말자. 대신 세터에 대해 오래 생각해 보자. 만일 요구사항 때문에 세터를 추가해야 한다면 세터를 사용한 후 내부 상태를 보호하고 검증하기 위한**변질방지계층** 을 사용하는 것을 고려하자.


### 06 JMH로 조금 더 쉽게 벤치마킹해 보자
JVM에서의 벤치마킹, 특히 마이크로벤치마킹은 어렵다. 
JMH는 올바른 마이크로벤치마크를 작성하기 위한 도구다. 같은 환경에서 실행하면 결과도 비교할 수 있으므로 벤치마크 결과를 해석하는 주된 방법으로 사용해야 한다. 게다가 안정적이며 반복적인 결과를 제공하므로 프로파일링 목적으로도 사용 할 수 있다.


### 07 아키텍처의 품질을 체계화하고 검증하는 방법의 장점
모두가 합의한 애플리케이션의아키텍처 품질을 코드화하고 강제하는 가장 중요한 곳은 여러분의 지속적 전달 빌드 파이프라인이다. 하지만 품질 검증을 자동화했다고 해서 팀이 표준과 품질 수준에 대한 논의를 중단해서는 안되며, 팀 내 또는 팀 간 의사소통이 줄어들어서도 안 된다. 즉, 빌드 파이프라인 내에서 품질 지표를 확인하고 게시하면, 다른 방법으로는 알아차리기 어려울 수 있는 아키텍처 품질의 점진적인 저하를 방지할 수 있다.


### 08 문제와 업무를 더 작은 단위로 나누기
직장에서의 업무와 시스템은 크고, 큰 문제는 해결하는데 오래 거린다. 더 안좋은 점은 뇌에 기억해야 할 것이 너무 많다는 점이다. 
이 문제를 해결하는 좋은 방법은 문제를 더 작은 조각으로 나누는 것이다. 더 작게 나눌수록 좋다. 일단 작은 문제를 하나 해결하면 더는 그 문제를 고민할 필요 없이 다른 문제로 넘어가면 된다. 문제를 잘 분할하면 그다음에는 작게 나눈 문제를 확인할 자동화된 테스트를 작성하게 된다. 또한 커밋도 더 자주 하게 된다. 커밋을 자주 하면 뭔가 원하는대로 동작하지 않을 때 롤백할 수 있는 지점이 생긴다


### 09 다양성을 인정하는 팀 만들기
협업은 이제 '훌륭한' 전문가를 구분하는 가치 있는 자질 중 하나가 됐다. 과거에는 독립적이며 자기 주도적이면 충분히 '훌륭하다'고 할 수 있었다. 현대의 우리는 모두가 피트 크루, 즉 팀의 구성원이다. 이제 문제는 다양성을 인정하면서도 성공적으로 기능하는 팀을 만드는 방법이다. 
협업의 핵심은 팀 내 심리적 안정성과 신뢰를 쌓는 것이다.


### 10 빌드는 느려서도 안 되고 불안정해서도 안 된다
어떤 빌드 도구를 사용하든, 개발자 생산성을 책임지는 사람은 빌드 성능을 효율적으로 측정하고 성능이 떨어지는 원인을 추적하며 로컬 및 CI 빌드의 회귀 테스트를 실행한다. 이 역할을 하는 사람은 빌드 결과를 분석해 빌드 과정에서 병목을 일으키는 원인을 찾는다. 그리고 뭔가 잘못되면 보고서를 팀원과 공유하고 실패한 빌드와 성공한 빌드를 비교해 설령 자신의 머신에서 해당 이슈를 재현하지 못하더라도 정확한 원인을 찾아 낸다. 또한 개발자 생산성 담당자는 이렇게 축적된 데이터를 기반으로 빌드 프로세스를 최적화하고 개발자의 부담을 줄여준다. 사실 이 업무는 끝이 없으므로 개발자 생산성을 유지하는 일은 계속 반복된다.

### 11 아니, 내 머신에서는 잘 실행됐다니까!
코드로서의 인프라스트럭처 개념에 따르면, 도구를 제공하는 사람이나 조직은 사람의 개입 없이 표준화된 버전의 빌드 도구 런타임을 프로비저닝 할 수 잇는 솔루션인 래퍼를 제공한다. 래퍼는 런타임을 다운로드하고 설치하기 위한 과정을 감싼 것이다. '내 머신에서는 잘 실행됐다니까!' 라고 외치던 시절은 지났다. 한 번에 표준화하고 어디서든 실행하자. 모든 JVM 프로젝트에 래퍼 개념을 도입해서 빌드의 재현성과 유지보수성을 확보하자.


### 12 비대한 JAR은 이제 그만
애플리케이션을 하나의 거대한 JAR 파일을 사용하지 않고 다른 형태로 패키징해서 실행하는 것은 현대의 자바 웹 개발 환경에서는 금기시되고 있다. 하지만 프로젝트를 빌드하고 그 결과 파일을 배포하는 방법에도 단점은 있다. 그 중 한 가지 확실한 문제는 주로 JAR 파일의 크기가 스토리지 공간과 네트워크 대역폭보다 커지는 것이다. 게다가 일체형 빌드 절차는 시간도 오래 걸릴뿐더러, 개발자가 빌드를 기다리는 동안 다른 업무로 콘텍스트 스위칭하게 되기도 한다. 자바 애플리케이션을 하나의 커다란 JAR 파일에 담아 배포하는 방법은 마이크로서비스아키텍처, 데브옵스 그리고 클라우드나 컨테이너, 오케스트레이션 플랫폼 같은 기법의 등장과 더불어 점점 더 보편화 되고 있다. 하지만 일부 조직은 이런 방법에서 벗어나 '날씬한 JAR' 파일을 만들기 시작했다.



### 13 코드 복원전문가
**우리가 100년전에 만들어진 물건을 복원하는 사람을 위해 일하고 있다는 점을 명심해. 이 사람이야말고 우리가 닮고 싶은 사람이야** 
최고의 코드는 나중에 그 코드를 보게 될 프로그래머를 생각하며 작성한 코드다. 그렇기에 '(모두가 바라지만 거의 항상 실패하는) 같은 것을 더 나은 방법으로 다시 만드는'일이 아니라 기존 코드를 천천히 다듬어 다시 관리할 수 잇는 상태로 재창조하는 코드 복원 전문가가 필요하다. 여기에 테스트를 조금 더 추가하고, 말도 안되는 클래스를 잘게 나누고, 사용하지 않는 기능은 과감히 제거해서 더 나아진 코드를 다시 내놓는 그런 사람이 필요하다.


### 14 JVM의 동시성
애초에 JVM에서 가능한 동시성 모델은 원시 스레드 뿐이었으며 여전히 자바에서 병렬과 동시성 프로그램을 작성하기 위한 기본 옵션이다. 
요즘은 병렬화의 가용성과 기대로 인해 명시적 멀티스레딩의 한계가 더 명확해졌다. 스레드와 록은 너무 저수준이다. 즉, 제대로 사용하기가 어렵다. 자바 메모리 모델을 이해하는 것은 그보다 더 어렵다. 공유할 수 잇는 가변 상태를 이용해 통신하는 스레드는 대규모 병렬성에는 어울리지 않으며 메모리 접근이 제대로 동기화되지 않으면 어떤 결과가 나올 지 알 수 없다. 게다가 록을 제대로 사용하더라도 록의 목적은 병렬로 실행 중인 스레드로 제한되므로 애플리케이션의 병렬성을 오히려 감소시킨다. 
공유메모리 제한을 극복하는 가장 간단한 방법은 록 대신 분산 큐를 이용해 스레드를 조율하는 것이다. 즉, 공유 메모리 대신 메시지를 전달하는 방법이며 디커플링도 향상된다. 큐는 양방향 통신에 적합하지만 지연 응답이 발생할 수 있다.


### 15 CountDownLatch, 친구인가 적인가?


### 16 선언적 표현식은 병렬성으로 가는 지름길이다
자바는 태생적으로 명령형이자 객체 기반 프로그래밍 언어다. 하지만 발전을 거듭해 왔으며 단계마다 더 많은 선언적 표현식을 도입해왔다. 선언적 표현식의 핵심에는 고차 함수가 있다. 고차 함수란 **함수를 매개변수로 받으며 함수를 리턴하는 함수다.** 


### 17 더 나은 소프트웨어를 더 빨리 전달하기
1. 전달이란 코드를 작성하고 디버깅하는 것 이상의 책임을 갖는 것을 의미한다.
2. 더 나은 소프트웨어란 '올바른 기능을 구현'하는 것과 '올바르게 기능을 구현' 하는 두 가지 개념을 짧게 표현하는 것이다.
3. 빨리는 전달과 더 나은 소프트웨어를 모두 지칭하며 자칫 달성이 어려운 부분이 될 수 있다.

### 18 지금 몇 시예요?


### 19 기본 도구의 사용에 충실하자
모든 자바 프로그래머에게 필요한 기본 도구 하나를 꼽으라면? 답은  javac이다. IDE에만 의존하면 IDE가 의도적으로 정보를 은닉하므로 프로그래머가 자신이 사용하는 도구를 완벽하게 습득할 수 없다. 설정은 일단 한 번 적용하면 잊게 마련이다.


### 20 변수를 바꾸지 말자
값이 변하지 않은 변수를 불변 요소로 정의하면서 코드의 디자인을 조금 더 세심하게 고민하게 되고 잠재적인 버그도 찾을 수 있음을 깨닫는다. 덕분에 변숫갑싱 변경되는 부분과 그 동작의 범위를 지역화해야 할 부분을 명확하게 표현할 수 있다.


### 21 SQL식 사고 도입하기
SQL 쿼리의 장점을 생각해보자.
1. 조인 결과를 저장하기 위해 새 테이블이 필요하지 않다.
2. 쿼리는 선언적이다.
3. 도메인 전용 언어(DSL, Domain-Specific Language)는 문제에 잘 부합한다.


### 22 자바 컴포넌트 간의 이벤트
자바 객체지향성의 핵심 개념은 모든 클래스를 컴포넌트로 간주할 수 있다는 점이다. 자바의 이벤트는 컴포넌트의 상태를 변경하는 행위다. 


### 23 피드백 루프
- 개발자로서 나는 어떤 코드를 개발해야 할지 모르므로 제품 관리자로부터 요구 사항을 전달받는다. 이 과정에서 나도 요구사항을 잘못 이해할 수 있다.
- 구현 방법을 고민하는 동안 실수할 수 있으므로 동료와 함께 짝을 이뤄 일한다. 내 동료가 나의 실수를 고쳐준다.
- 내 동료도 사람이고 실수할 수 있으므로 단위 테스트를 작성한다. 단위 테스트가 우리의 실수를 고쳐준다.
- 코딩 업무를 함께하는 팀이 있으므로 팀의 코드에 우리가 작성한 코드를 통합한다. 우리가 실수를 저지르면 이 코드는 컴파일되지 않는다.
- 팀도 실수할 수 있으므로 전체 시스템을 점검하기 위한 수용테스트를 작성한다. 우리가 실수를 저지르면 수용 테스트가 실패한다.
-시장 상황은 계속 변화하므로 그전까지는 문제가 없던 부분도 결국에는 문제가 된다.
- 뭔가 잘못된다는 것은 결국 비용이 드는 것이므로 지금까지 나열한 것을 최대한 자주 수행한다. 그렇게 해서 실수를 최소화한다.
- 제대로 만드는 것을 고민하지 말고 잘못된 것을 어떻게 알아낼지, 잘못된 것을 찾았을 때 얼마나 쉽게 수정할 수 있는지를 고민하자. 왜냐하면 분명 뭔가 잘못될 것이기 때문이다.
**뭔가를 잘못 이해했더라도 괜찮다**

                        



